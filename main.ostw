import "settings.lobby";
import "trackAbilityLockout.del";


import "OSTWUtils/OnScreenText.del";
import "stateMachine.del";


playervar Hero trueHero;
playervar Hero ultimateHero;

globalvar Boolean FORCE_NON_NATIVE_ULTIMATE = WorkshopSettingToggle("Settings", "Force Random Ultimate To Be Non-Native", true, 0);
globalvar Boolean RANDOM_ULTIMATE_MATCHES_ROLE = WorkshopSettingToggle("Settings", "Force Random Ultimate To Match Role", false, 1);
globalvar Boolean SHOW_ULTIMATE_HERO = WorkshopSettingToggle("Settings", "Show Randomized Ultimate Hero", false, 3);

globalvar Boolean DEBUG_MODE = WorkshopSettingToggle("°DEBUG", "Debug Mode Enabled", false, 0);
globalvar Boolean DEBUG_SHOULD_FORCE_ULTIMATE_HERO = WorkshopSettingToggle("°DEBUG", "Force Ultimate Hero", false, 1);
globalvar Hero DEBUG_ULTIMATE_HERO = WorkshopSettingHero("°DEBUG", "Ultimate Hero to Force", Hero.Baptiste, 2);

globalvar Hero[] placeableUltimateHeroes = [Hero.Baptiste, Hero.Symmetra, Hero.Lifeweaver];
globalvar Hero[] ability1AllowedHeroes = [Hero.Dva];
globalvar Hero[] ability2AllowedHeroes = [];

// Rainbow code by PharingWell and Provoxin
Number rSaturation: 0.5;
Number rValue: 1.0;

Number rMin(Number rSaturation = rSaturation, Number rValue = rValue): 255 * (1-rSaturation) * (rValue);
Number rMax(Number rSaturation = rSaturation, Number rValue = rValue): 255 * rValue;
Number rMod: (rMax() - rMin()) * 6;
Number rOffset: rMax() - 2 * rMin();

Number rainbow_R(Number t): Min(Max(AbsoluteValue(((t + (0*rMod)/3) % rMod) - rMod/2) - rOffset, rMin()), rMax());
Number rainbow_G(Number t): Min(Max(AbsoluteValue(((t + (1*rMod)/3) % rMod) - rMod/2) - rOffset, rMin()), rMax());
Number rainbow_B(Number t): Min(Max(AbsoluteValue(((t + (2*rMod)/3) % rMod) - rMod/2) - rOffset, rMin()), rMax());
Color rainbow: CustomColor(rainbowVector.X, rainbowVector.Y, rainbowVector.Z, 255);

globalvar Vector rainbowVector = Vector(0,0,0);
Number rainbowRate: 900;

rule: "If not in DEBUG_MODE, disable inspector recording"
{
  if (!DEBUG_MODE) {
    DisableInspectorRecording();
  }
}

rule: "[wheelVisuals.del] Start chasing rainbowVector"
if (DEBUG_MODE)
{
  ChaseVariableAtRate(
    rainbowVector,
    Vector(
      rainbow_R(TotalTimeElapsed() * rainbowRate),
      rainbow_G(TotalTimeElapsed() * rainbowRate),
      rainbow_B(TotalTimeElapsed() * rainbowRate)),
    99999,
    RateChaseReevaluation.DestinationAndRate);
}

rule: "Global credit HUD"
{
  CreateHudText(
    AllPlayers(),
    Header: " Code: 12MET ",
    Subheader: <"<0> Mystery Ultimates", IconString(Icon.QuestionMark)>,
    Text: "By CactusPuppy",
    Location: Location.Right,
    SortOrder: -10,
    HeaderColor: Color.Orange,
    SubheaderColor: Color.White,
    TextColor: CustomColor(255, 255, 255, 128),
    Reevaluation: HudTextRev.VisibleTo,
    Spectators: Spectators.VisibleAlways
  );
  if (DEBUG_MODE) {
    CreateHudText(
      AllPlayers(),
      Subheader: "DEBUG MODE ENABLED",
      Location: Location.Right,
      SortOrder: -9,
      SubheaderColor: rainbow,
      Reevaluation: HudTextRev.VisibleToAndColor
    );
  }
}

rule: "Create randomized ultimate hero HUD"
Event.OngoingPlayer
if (SHOW_ULTIMATE_HERO)
{
  OnScreenText.CreateOnScreenText(
    VisibleTo: ultimateHero && ultimateState == UltimateState.NORMAL && UltimateChargePercent() == 100 ? EventPlayer() : null,
    Header: <"<0>: <1>", HeroIconString(ultimateHero), AbilityIconString(ultimateHero, Button.Ultimate)>,
    PositionX: 0,
    PositionY: -0.9,
    Scale: 4,
    InworldTextRev.VisibleToPositionAndString,
    Color.White,
    Spectators.VisibleNever,
    EventPlayer()
  );
}

rule: "Track player's true hero"
Event.OngoingPlayer
if (HasSpawned())
if (ultimateState == UltimateState.NORMAL)
if (trueHero != HeroOf())
{
  trueHero = HeroOf();

  # Prevent swapping to a different role
  if (AllDamageHeroes().Contains(trueHero)) SetAllowedHeroes(EventPlayer(), AllDamageHeroes());
  else if (AllTankHeroes().Contains(trueHero)) SetAllowedHeroes(EventPlayer(), AllTankHeroes());
  else if (AllSupportHeroes().Contains(trueHero)) SetAllowedHeroes(EventPlayer(), AllSupportHeroes());

  if (HeroOf() == ultimateHero) {
    AllowButton(EventPlayer(), Button.Ultimate);
  } else {
    DisallowButton(EventPlayer(), Button.Ultimate);
  }
}

rule: "If the player despawns for at least 0.25 seconds, reset their hero availability"
Event.OngoingPlayer
if (!HasSpawned())
{
  Wait(0.25, WaitBehavior.AbortWhenFalse);
  StopForcingHero(EventPlayer());
  ResetHeroAvailability();
}

playervar Hero[] eligibleHeroSwaps;

void ChooseNewUltimateHero() playervar "[SUB]: Choose a new ultimateHero"
{
  if (DEBUG_MODE && DEBUG_SHOULD_FORCE_ULTIMATE_HERO) {
    ultimateHero = DEBUG_ULTIMATE_HERO;
  } else {
    eligibleHeroSwaps = AllHeroes();

    if (RANDOM_ULTIMATE_MATCHES_ROLE) {
      if (AllTankHeroes().Contains(HeroOf())) eligibleHeroSwaps = AllTankHeroes();
      else if (AllDamageHeroes().Contains(HeroOf())) eligibleHeroSwaps = AllDamageHeroes();
      else if (AllSupportHeroes().Contains(HeroOf())) eligibleHeroSwaps = AllSupportHeroes();
    }

    if (FORCE_NON_NATIVE_ULTIMATE) eligibleHeroSwaps.ModRemoveByValue(HeroOf());

    ultimateHero = RandomValueInArray(eligibleHeroSwaps);
  }

  # If the ultimateHero matches their hero right now, then we can allow native ultimate.
  # Otherwise, we need to disable the ultimate button.
  if (ultimateHero == HeroOf()) {
    AllowButton(EventPlayer(), Button.Ultimate);
  } else {
    DisallowButton(EventPlayer(), Button.Ultimate);
    # Preload the hero that the player will be swapping to when they ult
    PreloadHero(EventPlayer(), ultimateHero);
  }
}

rule: "Choose the next ultimate hero when the player enters NORMAL mode"
Event.OngoingPlayer
if (HasSpawned())
if (ultimateState == UltimateState.NORMAL)
{
  ChooseNewUltimateHero();
}

rule: "If player used their native ultimate, choose a new ultimate hero after their ult is done"
Event.OngoingPlayer
if (HasSpawned())
if (IsUsingUltimate() || IsDuplicating())
{
  WaitUntil(!IsUsingUltimate() && !IsDuplicating(), 1000000);
  ChooseNewUltimateHero();
}

rule: "When player earns their ult, if ultimateHero is not their trueHero, preload ultimateHero"
Event.OngoingPlayer
if (HasSpawned())
if (ultimateState == UltimateState.NORMAL)
if (UltimateChargePercent() == 100)
if (ultimateHero != trueHero)
{
  PreloadHero(EventPlayer(), ultimateHero);
}

rule: "When the game is between rounds, issue a DIED event to knock all players out of their mystery ult"
Event.OngoingPlayer
if (IsBetweenRounds())
if (!IsMatchComplete())
{
  WaitUntil(!IsBetweenRounds(), 1000000);

  # Kick the player out of their mystery ult if they're still in it
  AbortIf(ultimateState == UltimateState.NORMAL);
  DispatchUltimateEvent(UltimateEvent.DIED);
  DispatchPreparingUltEvent(PreparingUltEvent.STATE_EXIT);
}

playervar Number extendedUltPercentLeft;
playervar Number ultCastStallDuration;
playervar Number extendedUltDuration;
playervar Any extendedUltTimer;

Number flashStart: 33;
Number flashEnd: 50;
Number flashMinOpacity: 32;
Number flashWeight(Player p = EventPlayer()): Min(1, Max(0, (p.extendedUltPercentLeft - flashStart) / (flashEnd - flashStart)));
Number flashFactor(Player p = EventPlayer()): SineFromRadians(SquareRoot(18 * p.extendedUltDuration * p.extendedUltPercentLeft)) / 2 + 0.5;

Boolean IsAbilitiesLocked(Player p = EventPlayer()): [IsHackAbilityLockoutActive(p), HasStatus(p, Status.Asleep), HasStatus(p, Status.Frozen), HasStatus(p, Status.KnockedDown), HasStatus(p, Status.Stunned)].IsTrueForAny((status) => status);

void SetStallDuration() playervar "[SUB]: Set cast stall duration"
{
  ultCastStallDuration = 0;
  switch (HeroOf()) {
    case Hero.Dva:
      ultCastStallDuration = 1.25;
      break;
    case Hero.Zarya:
      ultCastStallDuration = 0.75;
      break;
  }
}

void SetLingerDuration() playervar "[SUB]: Set linger duration"
{
  extendedUltDuration = 0;
  switch (HeroOf()) {
    case Hero.JunkerQueen:
      extendedUltDuration = 5;
      break;
    case Hero.WreckingBall:
      extendedUltDuration = 15;
      break;
    case Hero.Lifeweaver:
      extendedUltDuration = 15;
      break;
    case Hero.Tracer:
      extendedUltDuration = 3;
      break;
    case Hero.Illari:
      extendedUltDuration = 5;
      break;
    case Hero.Torbjorn:
      extendedUltDuration = 10;
      break;
    case Hero.Hanzo:
      extendedUltDuration = 10;
      break;
    case Hero.Bastion:
      extendedUltDuration = 1;
      break;
  }
}

rule: "DEBUG: When player melees, give them 25% ult charge"
Event.OngoingPlayer
if (DEBUG_MODE)
if (IsButtonHeld(EventPlayer(), Button.Melee))
{
  SetUltimateCharge(EventPlayer(), Min(100, UltimateChargePercent(EventPlayer()) + 25));
}

globalvar Boolean IsInSlowMotion;

rule: "DEBUG: When player hits reload and crouch, toggle slow motion"
Event.OngoingPlayer
if (DEBUG_MODE)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (IsButtonHeld(EventPlayer(), Button.Crouch))
{
  if (IsInSlowMotion) {
    SetSlowMotion(100);
  } else {
    SetSlowMotion(10);
  }
  IsInSlowMotion = !IsInSlowMotion;
}

rule: "DEBUG: When player holds crouch for 2 seconds, swap their hero"
Event.OngoingPlayer
if (DEBUG_MODE)
if (IsButtonHeld(EventPlayer(), Button.Crouch))
{
  Wait(2, WaitBehavior.AbortWhenFalse);
  Vector pos = PositionOf(EventPlayer());
  Vector facing = FacingDirectionOf(EventPlayer());
  SetAllowedHeroes(EventPlayer(), AllHeroes().Remove(HeroOf(EventPlayer())));
  WaitUntil(!HasSpawned(EventPlayer()), 1);
  ResetHeroAvailability();
  WaitUntil(HasSpawned(EventPlayer()), 1000000);
  Teleport(EventPlayer(), pos);
  StartFacing(EventPlayer(), facing, 1000, Relative.ToWorld, FacingRev.None);
  WaitUntil(AngleBetweenVectors(FacingDirectionOf(EventPlayer()), facing) < 0.1, 1000000);
  StopFacing(EventPlayer());
}

rule: "DEBUG: Shorten assembling heroes in DEBUG_MODE"
Event.OngoingGlobal
if (DEBUG_MODE)
if (IsAssemblingHeroes())
{
  Wait(0.1, WaitBehavior.AbortWhenFalse);
  SetMatchTime(5);
}

rule: "DEBUG: Say Goodbye to end round"
Event.OngoingPlayer
if (DEBUG_MODE)
if (IsCommunicating(EventPlayer(), Communication.Goodbye))
{
  SetMatchTime(0);
}
